function BytecodeTool() {
  const [sourceEditor, setSourceEditor] = React.useState(null);
  const [outputEditor, setOutputEditor] = React.useState(null);
  const [isDecompileMode, setIsDecompileMode] = React.useState(false);
  const [currentBytecode, setCurrentBytecode] = React.useState('');
  const [statusMsg, setStatusMsg] = React.useState('Ready');
  const [statusError, setStatusError] = React.useState(false);
  const [showModal, setShowModal] = React.useState(false);
  const [filename, setFilename] = React.useState('output');
  const [compilerInstance, setCompilerInstance] = React.useState(null);
  const [gbfLoaded, setGbfLoaded] = React.useState(false);
  const [converting, setConverting] = React.useState(false);
  const [copied, setCopied] = React.useState(false);
  const sourceContainerRef = React.useRef(null);
  const outputContainerRef = React.useRef(null);

  const hexToUint8Array = (hex) => { const bytes = []; for (let i = 0; i < hex.length; i += 2) bytes.push(parseInt(hex.substr(i, 2), 16)); return new Uint8Array(bytes); };
  const cleanupDecompiled = (code) => code.replace(/temp\d+/g, 'temp').replace(/:array\d+/g, ':array').replace(/\$ Temps\d+/g, '').replace(/\n{3,}/g, '\n\n').trim();
  const updateStatus = (msg, isError = false) => { setStatusMsg(msg); setStatusError(isError); };
  const updateUIForMode = () => { if (sourceEditor) sourceEditor.updateOptions({ wordWrap: isDecompileMode ? 'on' : 'off' }); };
  const getCompiler = async () => { if (compilerInstance) return compilerInstance; await new Promise(r => { const check = () => window.GS2Compiler ? r() : setTimeout(check, 50); check(); }); const compiler = new window.GS2Compiler(); setCompilerInstance(compiler); return compiler; };
  const downloadFile = (content, name) => { const blob = new Blob([content], { type: 'text/plain' }), url = URL.createObjectURL(blob), a = document.createElement('a'); a.href = url; a.download = name; a.click(); URL.revokeObjectURL(url); };
  const showSaveDialog = () => { setFilename(isDecompileMode ? 'output' : 'output.gbs'); setShowModal(true); setTimeout(() => document.querySelector('.byte-modal-input')?.focus(), 100); };
  const hideSaveDialog = () => setShowModal(false);
  const performSave = () => { const content = outputEditor?.getValue() || ''; if (!content) return updateStatus('No output to save!', true); downloadFile(content, filename || 'output'); updateStatus(`Saved as ${filename}`); hideSaveDialog(); };
  const flipInputOutput = () => { if (!sourceEditor || !outputEditor) return; const sourceContent = sourceEditor.getValue(), outputContent = outputEditor.getValue(); sourceEditor.setValue(outputContent); outputEditor.setValue(sourceContent); setCurrentBytecode(sourceContent); };
  const handleConvert = async () => {
    if (!sourceEditor || !outputEditor) return;
    const source = sourceEditor.getValue().trim();
    if (!source) return updateStatus('Please enter some code!', true);
    setConverting(true);
    try {
      if (isDecompileMode) {
        if (!/^[0-9a-fA-F\s]+$/.test(source)) return updateStatus('Invalid bytecode! Must be hex only.', true);
        if (!gbfLoaded) { await window.gbfWasmInit(); setGbfLoaded(true); }
        const bytes = hexToUint8Array(source.replace(/\s/g, ''));
        try { const decompiled = await window.gbfDecompileBytecode(bytes); outputEditor.setValue(cleanupDecompiled(decompiled)); updateStatus('Decompiled successfully!'); } catch (e) { updateStatus('Decompilation failed! Check bytecode format.', true); }
      } else {
        const compiler = await getCompiler();
        try { const bytecode = compiler.compile(source); const hex = Array.from(bytecode).map(b => b.toString(16).padStart(2, '0')).join(' '); outputEditor.setValue(hex); setCurrentBytecode(hex); updateStatus('Compilation successful!'); } catch (e) { updateStatus(`Compilation error: ${e.message}`, true); }
      }
    } catch (e) { updateStatus(`Error: ${e.message}`, true); } finally { setConverting(false); }
  };
  const handleClear = () => { if (sourceEditor) sourceEditor.setValue(''); if (outputEditor) outputEditor.setValue(''); setCurrentBytecode(''); updateStatus('Ready'); setStatusError(false); };
  const handleCopy = async () => { const content = outputEditor?.getValue() || ''; if (!content) return updateStatus('No output to copy!', true); try { await navigator.clipboard.writeText(content); setCopied(true); updateStatus('Copied to clipboard!'); setTimeout(() => setCopied(false), 2000); } catch { const ta = document.createElement('textarea'); ta.value = content; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); updateStatus('Copied to clipboard!'); } };
  const handleFilenameKeydown = (e) => { if (e.key === 'Enter') performSave(); else if (e.key === 'Escape') hideSaveDialog(); };
  const handleModalBackdropClick = (e) => { if (e.target.classList.contains('byte-modal-overlay')) hideSaveDialog(); };

  React.useEffect(() => {
    const originalError = console.error, originalWarn = console.warn;
    console.error = function(...args) { if (typeof args[0] === 'string' && (args[0].includes('Source map error') || args[0].includes('URL constructor'))) return; if (typeof args[0] === 'string' && args[0].includes('cloudflareinsights')) return; originalError.apply(console, args); };
    console.warn = function(...args) { if (typeof args[0] === 'string' && args[0].includes('Source map error')) return; originalWarn.apply(console, args); };
    return () => { console.error = originalError; console.warn = originalWarn; };
  }, []);

  React.useEffect(() => { if (isDecompileMode && currentBytecode) flipInputOutput(); updateUIForMode(); }, [isDecompileMode]);

  React.useEffect(() => {
    const handleGlobalKeydown = (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 's') { e.preventDefault(); showSaveDialog(); } };
    document.addEventListener('keydown', handleGlobalKeydown);
    return () => document.removeEventListener('keydown', handleGlobalKeydown);
  }, []);

  React.useEffect(() => {
    require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' } });
    require(['vs/editor/editor.main'], function() {
      monaco.languages.register({ id: 'gscript' });
      monaco.languages.setMonarchTokensProvider('gscript', {
        keywords: ['break','case','catch','class','continue','default','delete','do','else','elseif','extends','finally','for','function','if','implements','import','in','instanceof','new','return','super','switch','this','throw','try','typeof','while','with'],
        keywordsType: ['bool','char','const','float','int','long','var','void'],
        keywordsOther: ['null','this','parent','super','true','false','timeout','sleep','hide','show','setimg','setcharani','triggeraction','say','chat','warp','timetosecs','timetotime','addmsg','kill','setlevel','changeimgvis','showimg','hideimg','changeimgcolors','setposition','changeimgpart','isleader'],
        sqlKeywords: ['SELECT','INSERT','UPDATE','DELETE','FROM','WHERE','JOIN','INNER','LEFT','RIGHT','OUTER','ON','AND','OR','NOT','IN','EXISTS','BETWEEN','LIKE','ORDER','BY','GROUP','HAVING','DISTINCT','COUNT','SUM','AVG','MAX','MIN','UNION','INTERSECT','EXCEPT'],
        operators: ['+','-','*','/','%','=','==','!=','<','>','<=','>=','&&','||','!','&','|','^','~','<<','>>','++','--','+=','-=', '*=','/=','%','=','&=','|=','^=','<<=','>>='],
        symbols: /[=><!~?:&|+\-*\/\^%]+/,
        tokenizer: {
          root: [
            [/\s*#.*$/, 'comment'], [/\/\/.*$/, 'comment'], [/\/\*/, 'comment', '@comment'], [/\d*\.\d+([eE][\-+]?\d+)?/, 'number.float'], [/\d+/, 'number'], [/"([^"\\]|\\.)*$/, 'string.invalid'], [/"/, 'string', '@string'], [/\$[a-zA-Z_][a-zA-Z0-9_]*(?:::[a-zA-Z_][a-zA-Z0-9_]*)*/, 'variable.predefined'],
            [/[a-z_$][\w$]*/, { cases: { '@keywords': 'keyword', '@keywordsType': 'keyword.type', '@keywordsOther': 'keyword.other', '@default': 'identifier' } }], [/[A-Z][\w\$]*/, { cases: { '@sqlKeywords': 'keyword.other.sql', '@default': 'type.identifier' } }], { include: '@whitespace' }, [/@[a-zA-Z_][a-zA-Z0-9_]*/, 'annotation'], [/[{}()\[\]]/, '@brackets'], [/@symbols/, { cases: { '@operators': 'operator', '@default': '' } }]
          ],
          string: [[/\b(SELECT|INSERT|UPDATE|DELETE|FROM|WHERE|JOIN|INNER|LEFT|RIGHT|OUTER|ON|AND|OR|NOT|IN|EXISTS|BETWEEN|LIKE|ORDER|BY|GROUP|HAVING|DISTINCT|COUNT|SUM|AVG|MAX|MIN|UNION|INTERSECT|EXCEPT)\b/, 'keyword.other.sql'], [/[^\\"]+/, 'string'], [/"/, 'string', '@pop']],
          comment: [[/[^\/*]+/, 'comment'], [/\/\*/, 'comment', '@push'], ['\\*/', 'comment', '@pop'], [/[\/*]/, 'comment']],
          whitespace: [[/[ \t\r\n]+/, 'white'], [/\/\*/, 'comment', '@comment'], [/\/\/.*$/, 'comment']]
        }
      });
      monaco.editor.defineTheme('dracula', { base: 'vs-dark', inherit: true, rules: [{ background: '1e1f29' }, { token: '', foreground: 'f8f8f2', background: '1e1f29' }, { token: 'comment', foreground: '6272a4' }, { token: 'string', foreground: 'f1fa8c' }, { token: 'number', foreground: 'bd93f9' }, { token: 'keyword', foreground: 'ff79c6' }, { token: 'keyword.type', foreground: '8be9fd' }, { token: 'keyword.other.sql', foreground: 'ffb86c' }, { token: 'keyword.other', foreground: '50fa7b' }, { token: 'operator', foreground: 'ff79c6' }, { token: 'variable.predefined', foreground: 'ff79c6' }, { token: 'identifier', foreground: 'f8f8f2' }], colors: ['editor.background', '#1e1f29', 'editor.foreground', '#f8f8f2', 'editorCursor.foreground', '#f8f8f2', 'editor.lineHighlightBackground', '#282a36', 'editorLineNumber.foreground', '#6272a4', 'editor.selectionBackground', '#44475a', 'editor.inactiveSelectionBackground', '#282a36'] });
      const se = monaco.editor.create(sourceContainerRef.current, { value: '', language: 'gscript', theme: 'dracula', automaticLayout: true, fontSize: 13, fontFamily: "'Consolas', 'Monaco', 'Courier New', monospace", lineHeight: 21, minimap: { enabled: false }, scrollBeyondLastLine: false, wordWrap: 'off', tabSize: 4, renderLineHighlight: 'none', overviewRulerLanes: 0, hideMarkersInOverviewRuler: true, scrollbar: { useShadows: false } });
      const oe = monaco.editor.create(outputContainerRef.current, { value: '', language: 'gscript', theme: 'dracula', automaticLayout: true, fontSize: 13, fontFamily: "'Consolas', 'Monaco', 'Courier New', monospace", lineHeight: 21, readOnly: true, stopRenderingLineAfter: -1, wordWrap: 'on', minimap: { enabled: false }, scrollBeyondLastLine: false, tabSize: 4, renderLineHighlight: 'none', overviewRulerLanes: 0, hideMarkersInOverviewRuler: true, scrollbar: { useShadows: false } });
      setSourceEditor(se);
      setOutputEditor(oe);
      updateStatus('Ready');
    });
    return () => { if (sourceEditor) sourceEditor.dispose(); if (outputEditor) outputEditor.dispose(); };
  }, []);

  return (
    <>
      <div className="contain-bg2"></div>
      <div className={`modal-overlay byte-modal-overlay ${showModal ? 'show' : ''}`} onClick={handleModalBackdropClick}>
        <div className="modal-dialog byte-modal-dialog" onClick={e => e.stopPropagation()}>
          <div className="modal-header byte-modal-header">Save Bytecode</div>
          <input type="text" className="modal-input byte-modal-input" value={filename} onChange={e => setFilename(e.target.value)} onKeyDown={handleFilenameKeydown} placeholder="Enter filename..." />
          <div className="modal-buttons byte-modal-buttons">
            <button className="modal-btn byte-modal-btn byte-modal-btn-secondary" onClick={hideSaveDialog}>Cancel</button>
            <button className="modal-btn byte-modal-btn byte-modal-btn-primary" onClick={performSave}>Save</button>
          </div>
        </div>
      </div>
      <div className="byte-container">
        <div style={{position:'absolute',top:'20px',left:'20px',zIndex:1000}}>
          <a href="/" style={{fontSize:'16px',color:'#40ff40',cursor:'pointer',textDecoration:'none'}}><i className="fas fa-arrow-left"></i> Back</a>
        </div>
        <div className="byte-main" style={{paddingTop:'60px'}}>
          <div className="byte-panel">
            <div className="byte-panel-header">{isDecompileMode ? 'Bytecode Input' : 'GS2 Source Code'}</div>
            <div className="byte-panel-body" style={{padding:0}}>
              <div ref={sourceContainerRef} className="byte-editor-container"></div>
            </div>
          </div>
          <div className="byte-panel">
            <div className="byte-panel-header">
              <span>{isDecompileMode ? 'GS2 Output (WIP)' : 'Bytecode Output'}</span>
              <button className="byte-copy-btn" onClick={handleCopy} title="Copy to clipboard">{copied ? 'âœ“' : 'ðŸ“‹'}</button>
            </div>
            <div className="byte-panel-body" style={{padding:0}}>
              <div ref={outputContainerRef} className="byte-editor-container"></div>
            </div>
          </div>
        </div>
        <div className="byte-controls">
          <div className="byte-mode-toggle">
            <input type="checkbox" checked={isDecompileMode} onChange={e => setIsDecompileMode(e.target.checked)} id="decompileMode" />
            <label htmlFor="decompileMode">Decompile</label>
          </div>
          <button onClick={handleConvert} disabled={converting}>{isDecompileMode ? 'Decompile to GS2' : 'Convert to Bytecode'}</button>
          <button onClick={showSaveDialog} className="btn-save">{isDecompileMode ? 'Save GS2 Code' : 'Save Bytecode'}</button>
          <button onClick={handleClear}>Clear</button>
        </div>
        <div className={`info ${statusError ? 'error' : ''}`}>{statusMsg}</div>
      </div>
    </>
  );
}
